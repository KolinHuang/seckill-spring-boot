## Seckill-spring-boot

2021-4-20重构：

首先分析重构前的核心业务逻辑：

1. 鉴权部分：本项目利用加密后（加盐+md5）的token来实现鉴权，具体是在HTTP的Cookie中放入加密处理后的token字段，并将这个token存到存到redis中；每个用户的请求访问服务器时，首先从请求的cookies中找出这个token，再去redis中匹配是否存在此token，存在的话就鉴权成功。
2. 用户点击立即秒杀按钮，向服务器发送`seckill/path/{goodsId}`请求，服务器首先进行鉴权（Cookie实现），鉴权通过后将当前用户的信息和商品信息与利用MD5生成的随机数混合，生成秒杀商品的地址，放入redis，随后返回给前端。
3. 对于请求`seckill/path/{goodsId}`，利用拦截器实现了接口限流，5秒钟内同一个用户访问此接口的次数不能超过5次。
4. 前端接收到url后，立即发送Ajax请求`seckill/{path}/seckill/{goodsId}`到服务器进行秒杀。服务器从请求路径中取出path和商品ID用于检查url的合法性，合法性校验通过了，就开始判断库存。
5. 这里可以用内存标记来减少访问redis的次数，提高效率。但是还是需要视具体情况而定，如果秒杀商品数量没有特别多，那么可以把商品的状态（布尔值，true表示卖完了，false表示还没卖完）放到内存的哈希表里。如果秒杀商品非常多，那么这个哈希表可能会占用比较多的内存，就没必要使用了。具体还需要根据线上环境配置，如果有负载均衡等措施，那么单个服务器负责的商品数量不会很多，用内存标记反而可以稍微提升效率。
6. 在检查库存的时候，先从内存标记的ConcurrentHashMap中查看商品状态，如果显示商品已售空，就返回，既不查redis，也不查数据库；如果显示商品仍有库存，就调用redis的API减库存（jedis.decr()，是原子操作），返回剩余库存。如果剩余库存是负数，那么说明这个请求在查询redis时，库存已经为空了，那就返回；如果剩余库存不为负数（包括0），则说明成功抢到了库存，就把订单信息放到消息队列中慢慢异步处理，给前端返回秒杀成功标志即可。
7. 消息队列中都是秒杀成功的，待处理的订单信息，我们把真正减数据库库存的操作放到这里。具体就是根据消息中的商品ID从数据库中查询库存，如果库存充足就减库存，创建新的订单插入到订单表中。



以上就是本项目的核心业务逻辑。缺点很多，一一分析：

1. 限流：在后端使用拦截器进行限流。对于一个用户来说，5秒内的前5次请求都是正常放行的，从第6次开始进行拦截。拦截的判断操作是从redis中查看该用户对应的键是否过期（过期时间是5秒）。缺点就是限流算法过于简单，





解决限流问题：

实际场景中经常使用的限流措施：

1. Web前端限流，让按钮置灰；
2. Nginx前端限流，按照一定的规则如IP、系统调用逻辑等在Nginx层面做限流；
3. 漏斗限流和令牌桶限流（常用）。