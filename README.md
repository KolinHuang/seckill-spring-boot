## Seckill-spring-boot

2021-4-20重构：

首先分析重构前的核心业务逻辑：

1. 鉴权部分：本项目利用加密后（加盐+md5）的token来实现鉴权，具体是在HTTP的Cookie中放入加密处理后的token字段，并将这个token存到redis中；每个用户的请求访问服务器时，首先从请求的cookies中找出这个token，再去redis中匹配是否存在此token，存在的话就鉴权成功。
2. 在加载项目的时候，就将秒杀的商品信息和库存放入redis中，即缓存预热。
3. 浏览商品阶段，会将商品页面进行懒加载，有请求时，从数据库里查数据，然后把渲染好的页面放到redis里。
4. 用户点击立即秒杀按钮，向服务器发送`seckill/path/{goodsId}`请求，服务器首先进行鉴权（Cookie实现），鉴权通过后将当前用户的信息和商品信息与利用MD5生成的随机数混合，生成秒杀商品的地址，放入redis，随后返回给前端。
5. 对于请求`seckill/path/{goodsId}`，利用拦截器+redis实现接口限流，5秒钟内同一个用户访问此接口的次数不能超过5次。
6. 前端接收到url后，立即发送Ajax请求`seckill/{path}/seckill/{goodsId}`到服务器进行秒杀。服务器从请求路径中取出path和商品ID用于检查url的合法性，合法性校验通过了，就开始判断库存。
7. 这里可以用内存标记来减少访问redis的次数，提高效率。但是还是需要视具体情况而定，如果秒杀商品数量没有特别多，那么可以把商品的状态（布尔值，true表示卖完了，false表示还没卖完）放到内存的哈希表里。如果秒杀商品非常多，那么这个哈希表可能会占用比较多的内存，就没必要使用了。具体还需要根据线上环境配置，如果有负载均衡等措施，那么单个服务器负责的商品数量不会很多，用内存标记反而可以稍微提升效率。
8. 在检查库存的时候，先从内存标记的ConcurrentHashMap中查看商品状态，如果显示商品已售空，就返回，既不查redis，也不查数据库；如果显示商品仍有库存，就调用redis的API减库存（jedis.decr()，是原子操作），返回剩余库存（这里实现了防止超卖）。如果剩余库存是负数，那么说明这个请求在查询redis时，库存已经为空了，那就返回；如果剩余库存不为负数（包括0），则说明成功抢到了库存，就把订单信息放到消息队列中慢慢异步处理，给前端返回秒杀成功标志即可。
9. 消息队列中都是秒杀成功的，待处理的订单信息，我们把真正减数据库库存的操作放到这里。具体就是根据消息中的商品ID从数据库中查询库存，如果库存充足就减库存，创建新的订单插入到订单表中。



以上就是本项目的核心业务逻辑。缺点很多，一一分析：

1. 限流：在后端使用拦截器进行限流。对于一个用户来说，5秒内的前5次请求都是正常放行的，从第6次开始进行拦截。拦截的判断操作是从redis中查看该用户对应的键是否过期（过期时间是5秒）。缺点就是限流算法过于简单，因为只对单个用户进行了限流（防止脚本抢购），如果同时有几十万个用户进来，那5秒内就可能会有上百万的QPS，服务器也是扛不住的。

2. 仔细分析发现，鉴权、秒杀路径、秒杀商品库存、限流都用redis去实现，那如果redis挂了，岂不是什么都挂了。缺点就是没有backup，应当适当允许直接操纵数据库。

3. 在秒杀的时候，当权限和秒杀路径都校验通过时，所有的请求都会打到redis中，会不会是一个性能瓶颈？

4. 在浏览商品阶段，本项目将商品的静态页面也缓存到了redis中，但是没有设置过期时间，应当是要设置一个过期时间的，因为redis的资源也是很宝贵的，而且后面手动去删除就很麻烦。为了防止缓存雪崩，给这些数据设置一个base+随机增量时间的过期时间。

5. 同时，在浏览商品阶段是有可能发生缓存穿透的，因为当用户点到一个商品的详情页时，会给服务器发一个请求`/detail/{goodsId}`，如果在redis中找到了这个商品信息，那就可以直接返回，但是如果找不到，请求就打到数据库了。问题就出在这里，攻击者会模拟许多**不存在的商品ID 请求**，尽管做了层层限流，但是如果攻击者的主机数目比较多（伪造IP绕过了限流算法），那数据库的压力还是非常大的。

6. 缓存击穿也是有可能发生的，但是条件比较苛刻。首先是在缓存中查不到商品，这有几种可能：

   1. 这个商品本来就没有；
   2. 商品数量太多，并没有全数放入缓存；
   3. 缓存中的商品信息过期了或redis挂了；

   出现上述情况时，请求会被直接打到数据库，如果这时候并发用户特别多，并且同时读缓存没有读到数据，又同时去数据库取数据，那数据库的压力就会瞬间增大，这就发生了缓存击穿。

7. 





**解决redis故障，导致服务不可用问题**：

1. 可以采用redis集群实现高可用；
2. 用数据库+乐观锁作为backup；

我使用第二种方案。

问题是，redis挂了，那里面的数据一时半会恢复不过来，那么我们不知道目前库存减到了什么程度，怎么办？

在正常流程中，订单都是交给消息队列异步处理的，由消息队列去数据库减库存，如果此时消息队列已经处理了10个消息，商品库存-10，还剩下90个，假如此时消息队列中还有90个在排队，这90个消息都应该是抢购成功的消息。

如果这时候redis发生了故障，那么我们只能从数据库中读库存数据，这时候读出库存数据可能还是90，但是实际上在消息队列中已经有90个人把这些库存分完了，但是我们查出的库存还有90，会继续处理用户的购买请求，这会导致超卖问题。

我们可以用乐观锁来防止数据库层面的超卖问题，但是在业务层面，必定会有超过100个用户被提示了购买成功，比如120个被提示了购买成功，由于数据库的乐观锁机制，剩余的20人不会被生成订单信息。

思前想后，我觉得可以这么处理：

```markdown
1. 如果秒杀商品只有一种，那我们可以用一个AtomicLong原子变量在内存中维护进入消息队列的消息数目；
2. 当后端发现redis服务不可用了，就先短暂地丢弃未进入消息队列的所有请求；
3. 然后我们从数据库中读库存数据，再减去AtomicLong原子变量中的消息数目，就是剩余的库存数量；
4. 最后恢复请求处理。
```

当秒杀商品有多种时，就用`ConcurrentHashMap<商品ID，AtomicLong变量>`来存消息数目，然后再查库存更新。

虽然这会短暂地导致秒杀服务不可用（可预见的是，停顿的时间应该很短），但是也是一种解决思路。



**解决限流问题：**

实际场景中经常使用的限流措施：

1. Web前端限流，让按钮置灰；
2. Nginx前端限流，按照一定的规则如IP、系统调用逻辑等在Nginx层面做限流；
3. 漏斗限流和**令牌桶限流**（常用）。

我使用令牌桶算法改进：采用Guava的RateLimiter工具类实现：

```java
@AccessLimit(seconds = 5,maxCount = 5)//单个用户的接口限流
@GetMapping("/path")
@ResponseBody
public Result<String> getSeckillPath(HttpServletRequest request,@RequestParam("goodsId") long goodsId){
  String loginToken = CookieUtils.readLoginToken(request);
  User user = redisService.get(UserKey.getByName, loginToken, User.class);
  if(user == null){
    return Result.error(CodeMsg.USER_NO_LOGIN);
  }
  //如果在1秒内没有获取到令牌，那就抛弃请求
  if(!rateLimiter.tryAcquire(1, TimeUnit.SECONDS)){//所有请求的接口限流
    return Result.error(CodeMsg.RATE_LIMIT);
  }
  String url = seckillOrderService.createUrl(user, goodsId);
  return Result.success(url);
}
```





**解决缓存穿透问题：**

1. 在接口层增加校验，用户鉴权已经做了，可以在商品ID上做文章，有一些明显是非法ID的直接拦截，比如`ID < 0`的情况。
2. 如果请求被打到了数据库，但是数据库也没有查到这个数据，那就把这个请求对应的ID放到redis里，value设置为null，过期时间可以设置的短一点，这样可以防止同一个商品ID暴力攻击。
3. 还有一个经典的实现，就是布隆过滤器，让那些不存在的ID直接拦截在这一层。

使用布隆过滤器实现：



**解决缓存击穿问题：**

实际上出现缓存击穿问题通常**不是商品的库存信息失效造成的**，通常是**热点页面失效造成的**。比如有一个商品的详情页面，我们在将其放入缓存的时候，设置了一个不太长的失效时间。假设过了一段时间后，这个商品的详情页失效了，又恰巧来了大量的并发用户在请求这个页面，就容易发生缓存击穿问题。

1. 把热点数据的过期时间设置得长一些。
2. 加读写锁。加载商品详情页不太可能有写请求，一般都是读请求，用读写锁可以提高并发读的效率。

使用读写锁实现：

