## Seckill-spring-boot

2021-4-20重构：

首先分析重构前的核心业务逻辑：

1. 鉴权部分：本项目利用加密后（加盐+md5）的token来实现鉴权，具体是在HTTP的Cookie中放入加密处理后的token字段，并将这个token存到redis中；每个用户的请求访问服务器时，首先从请求的cookies中找出这个token，再去redis中匹配是否存在此token，存在的话就鉴权成功。
2. 在加载项目的时候，就将秒杀的商品信息和库存放入redis中，即缓存预热。
3. 浏览商品阶段，会将商品页面进行懒加载，有请求时，从数据库里查数据，然后把渲染好的页面放到redis里。
4. 用户点击立即秒杀按钮，向服务器发送`seckill/path/{goodsId}`请求，服务器首先进行鉴权（Cookie实现），鉴权通过后将当前用户的信息和商品信息与利用MD5生成的随机数混合，生成秒杀商品的地址，放入redis，随后返回给前端。
5. 对于请求`seckill/path/{goodsId}`，利用拦截器+redis实现接口限流，5秒钟内同一个用户访问此接口的次数不能超过5次。
6. 前端接收到url后，立即发送Ajax请求`seckill/{path}/seckill/{goodsId}`到服务器进行秒杀。服务器从请求路径中取出path和商品ID用于检查url的合法性，合法性校验通过了，就开始判断库存。
7. 这里可以用内存标记来减少访问redis的次数，提高效率。但是还是需要视具体情况而定，如果秒杀商品数量没有特别多，那么可以把商品的状态（布尔值，true表示卖完了，false表示还没卖完）放到内存的哈希表里。如果秒杀商品非常多，那么这个哈希表可能会占用比较多的内存，就没必要使用了。具体还需要根据线上环境配置，如果有负载均衡等措施，那么单个服务器负责的商品数量不会很多，用内存标记反而可以稍微提升效率。
8. 在检查库存的时候，先从内存标记的ConcurrentHashMap中查看商品状态，如果显示商品已售空，就返回，既不查redis，也不查数据库；如果显示商品仍有库存，就调用redis的API减库存（jedis.decr()，是原子操作），返回剩余库存（这里实现了防止超卖）。如果剩余库存是负数，那么说明这个请求在查询redis时，库存已经为空了，那就返回；如果剩余库存不为负数（包括0），则说明成功抢到了库存，就把订单信息放到消息队列中慢慢异步处理，给前端返回秒杀成功标志即可。
9. 消息队列中都是秒杀成功的，待处理的订单信息，我们把真正减数据库库存的操作放到这里。具体就是根据消息中的商品ID从数据库中查询库存，如果库存充足就减库存，创建新的订单插入到订单表中。



以上就是本项目的核心业务逻辑。缺点很多，一一分析：

1. 限流：在后端使用拦截器进行限流。对于一个用户来说，5秒内的前5次请求都是正常放行的，从第6次开始进行拦截。拦截的判断操作是从redis中查看该用户对应的键是否过期（过期时间是5秒）。缺点就是限流算法过于简单。

2. 仔细分析发现，鉴权、秒杀路径、秒杀商品库存、限流都用redis去实现，那如果redis挂了，岂不是什么都挂了。缺点就是没有backup，应当适当允许直接操纵数据库。

3. 在秒杀的时候，当权限和秒杀路径都校验通过时，所有的请求都会打到redis中，会不会是一个性能瓶颈？

4. 在浏览商品阶段，本项目将商品的静态页面也缓存到了redis中，但是没有设置过期时间，应当是要设置一个过期时间的，因为redis的资源也是很宝贵的，而且后面手动去删除就很麻烦。为了防止缓存雪崩，给这些数据设置一个base+随机增量时间的过期时间。

5. 同时，在浏览商品阶段是有可能发生缓存穿透的，因为当用户点到一个商品的详情页时，会给服务器发一个请求`/detail/{goodsId}`，如果在redis中找到了这个商品信息，那就可以直接返回，但是如果找不到，请求就打到数据库了。问题就出在这里，攻击者会模拟许多**不存在的商品ID 请求**，尽管做了层层限流，但是如果攻击者的主机数目比较多（伪造IP绕过了限流算法），那数据库的压力还是非常大的。

6. 缓存击穿也是有可能发生的，但是条件比较苛刻。首先是在缓存中查不到商品，这有几种可能：

   1. 这个商品本来就没有；
   2. 商品数量太多，并没有全数放入缓存；
   3. 缓存中的商品信息过期了或redis挂了；

   出现上述情况时，请求会被直接打到数据库，如果这时候并发用户特别多，并且同时读缓存没有读到数据，又同时去数据库取数据，那数据库的压力就会瞬间增大，这就发生了缓存击穿。

7. 





**解决限流问题：**

实际场景中经常使用的限流措施：

1. Web前端限流，让按钮置灰；
2. Nginx前端限流，按照一定的规则如IP、系统调用逻辑等在Nginx层面做限流；
3. 漏斗限流和**令牌桶限流**（常用）。



**解决缓存穿透问题：**

1. 在接口层增加校验，用户鉴权已经做了，可以在商品ID上做文章，有一些明显是非法ID的直接拦截，比如`ID < 0`的情况。
2. 如果请求被打到了数据库，但是数据库也没有查到这个数据，那就把这个请求对应的ID放到redis里，value设置为null，过期时间可以设置的短一点，这样可以防止同一个商品ID暴力攻击。
3. 还有一个经典的实现，就是布隆过滤器，让那些不存在的ID直接拦截在这一层。



**解决缓存击穿问题：**

实际上出现缓存击穿问题通常**不是商品的库存信息失效造成的**，通常是**热点页面失效造成的**。比如有一个商品的详情页面，我们在将其放入缓存的时候，设置了一个不太长的失效时间。假设过了一段时间后，这个商品的详情页失效了，又恰巧来了大量的并发用户在请求这个页面，就容易发生缓存击穿问题。

1. 把热点数据的过期时间设置得长一些。
2. 加读写锁。加载商品详情页不太可能有写请求，一般都是读请求，用读写锁可以提高并发读的效率。

